<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Test Blog]]></title>
    <url>%2F2019%2F03%2F27%2FTest-Blog%2F</url>
    <content type="text"><![CDATA[首先介绍一下ode45的格式： [t,y] = ode45(odefun,tspan,y0) [t,y] = ode45(odefun,tspan,y0,options) [t,y,te,ye,ie] = ode45(odefun,tspan,y0,options) sol = ode45(___) 这里介绍一阶微分方程： [自变量，因变量] = ode45(方程，范围，初值); &nbsp; 举个栗子： &nbsp; 首先创建一个func2.m函数存放方程表达式 function Biubiu = func2(h, t) g = 9.8; Biubiu = (10000*pi/sqrt(2*g))*(h.^(3/2) - 2*(h.^(1/2))); end 接着在MATLAB命令窗口输入： tspan = [1 0];%函数范围 t_1 = 0;%初值 [h,t] = ode45(@func2, hspan, t_1); plot(h,t);%绘图 &nbsp; 可以丰富一下图像，增加横坐标名，纵坐标名和标题 xlabel('h值') ylabel('y值') title('一阶微分方程') &nbsp; 相关资料访问：https://ww2.mathworks.cn/help/matlab/ref/ode45.html?s_tid=doc_ta]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>ode45</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test Blog2]]></title>
    <url>%2F2019%2F03%2F27%2FTest-Blog2%2F</url>
    <content type="text"><![CDATA[一个机器人位于一个&nbsp;m x n&nbsp;网格的左上角 （起始点在下图中标记为&ldquo;Start&rdquo; ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为&ldquo;Finish&rdquo;）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m&nbsp;和&nbsp;n&nbsp;的值均不超过 100。 示例&nbsp;1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向右 -&gt; 向下 2. 向右 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向右 示例&nbsp;2: 输入: m = 7, n = 3 输出: 28 可以观察规律，矩阵中数字表示起点到这个地方有多少条路。 1 1 1 1 1 1 2 3 4 5 1 3 6 10 15 发现坐标(i,j)路的条数，可以通过关系式：way[i][j] = way[i - 1][j] + way[i][j - 1];计算 #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;memory&gt; #include &lt;numeric&gt; using namespace std; static int x = []() {std::ios::sync_with_stdio(false); cin.tie(0); return 0; }(); class Solution { public: int uniquePaths(int m, int n) { vector&lt;vector&lt;int&gt; &gt; way(m, vector&lt;int&gt;(n, 1)); for (int i = 1; i &lt; m; ++i) { for (int j = 1; j &lt; n; ++j) { way[i][j] = way[i - 1][j] + way[i][j - 1]; } } return way[m - 1][n - 1]; } }; int main() { Solution A; int m = 7, n = 3; cout &lt;&lt; A.uniquePaths(m, n); system("PAUSE"); return 0; } &nbsp; 注意：memset()是按字节赋值，只能够赋值-1或0。 当我们赋值1时，1转换为二进制00000001，占1字节，int型为4字节，因此实际上赋值的是：0000 0001,0000 0001,0000 0001,0000 0001 也就是16843009 &nbsp; int ptr** = new int*[m]; for(int i = 0; i &lt; m; ++i) { ptr[m] = new int[n]; } .... for(int i = 0; i &lt; m;++i) delete[] ptr[m]; } delete []ptr;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,Hk_Mayfly!]]></title>
    <url>%2F2019%2F03%2F26%2FHello-Hk-Mayfly%2F</url>
    <content type="text"><![CDATA[Biubiubiu!!!博客完善期，等待上线!!!]]></content>
      <categories>
        <category>搭建GitHub博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
